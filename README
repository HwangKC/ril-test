    最早的测试方式：
通过一个xml文件定义了所有的测试用例，每个用例中由需发送的AT命令、期待响应（通过正则表达式匹配）、超时时间组成，然后一个个跑测试用例。
每个测试用例由类似这样的结构组成：
	<cmd timeout="100">
		<name>AT+UMID</name>
 		<rsp>+UMID:</rsp>
 		<rsp>OK</rsp>
	</cmd>

    可是根据我的实际经验，这种方法有几个硬伤： 
1. 每测试一个新模组，配置文件要重写一次，重复工作很多,不能一劳永逸。
2. 只能测试单个AT命令是否支持，测试功能性bug时，会很麻烦。例如我想测试自发自收短信，怎么弄?
3. 配置文件的可读性太差，无法很直观的表达测试用例的思路流程。

    改良后的测试方式：
不直接和串口通过AT命令交互，而是上升一个层次，以RIL插件为基本测试对象。
开发过RIL插件的同学都知道，RIL插件相当于一个模组抽象层。在rild启动后，它以dlopen方式被加载，并通过执行RIL_Init函数完成插件初始化,
例如串口初始化，及一些基本的初始化AT指令。RIL插件和上层通过两种方式交互： 
1. 上层下发的消息命令。当用户执行某些操作时，通过Android框架以消息的形式转发至RIL插件，并转换为对应模组的AT指令序列，完成相应消息
的功能（例如RIL_REQUEST_DIAL消息是用于打电话的）。

2. 模组实时状态变化指示。例如接收到新来电、新短信、信号强度发生变化，这些变化指示同样以AT 形式上报。在RIL插件接收到变化时，就会转换为
Android RIL 预定义的消息格式，通过Android框架逐层转发。

每添加一个模组都必须实现一套完全适配该模组的新插件，这是不可避免的。某一天我突然想到，RIL插件已经将串口操作封装其中，对上层形成了统一的
抽象，即虽内部实现AT不一样，外部消息交互接口都是一致的。
与其对串口通过原始的AT指令测试，为什么不直接以插件为测试对象，通过统一消息与其交互，并完成测试功能呢？
总结起来，改良后的测试方式相比之前有几个好处：
1. 测试代码只要写一套， 不管谁添加了什么新模组，由于插件消息是接口是统一的，测试代码可以安心的忽视这些变化。
2. 可读性大大加强，消息的抽象程度远比对AT命令大。

目前我完成了常见的功能用例的编写，后续随着测试程度的加深，可以逐步扩充测试用例，不让一个bug漏掉。

    实现思路介绍：
首先我创建了一个类抽象：modem-control, 将对RIL插件的操作进行了进一步的封装。
所有测试用例都通过modem-control下发指令以及接受主动上报。
在main.c 中运行了所有的测试用例，大致过程是：创建modem-control对象实例，发送测试指令（如拨打电话），随后发送查询指令，查询
当前状态（如查询通话列表），查询的返回值需与预期一致，方能通过测试用例。对于某些难于查询的用例（如自发自收短信后，很难主动查询是否收到了短信），
可以设置unsol listener来监听异步事件上报，以完成测试。

modem-control 提供了基本的命令接口，对底层进行了进一步封装，面向调用者的接口都比较易读，
诸如打电话至某个号码，发短信至某个号码等。
在modem-control实现中，和rild一样，先调用dlopen加载RIL插件，然后通过RIL_Init标准接口完成插件的初始化以及将自身的回调函数注册至插件。
回调函数由3部分组成：
    onRequestComplete,
    onUnsolicitedResponse,
    RIL_requestTimedCallback
突然我觉得代码写得还是比较简单的，不想赘述了。just RTFSC. 

    使用方法：
adb remount 
adb shell mv system/bin/rild system/bin/rild_bak
adb push RIL_TEST system/bin/rild
chmod 777 system/bin/rild
setprop test.simstatus <0/1>
killall rild

...testing...
adb logcat -b radio |busybox grep RIL_TEST

...after test...
adb shell mv system/bin/rild_bak system/bin/rild

    最后说明：
这是个不成熟的软件，需要后续持续的改进。
虽然可能不好用，但这个方法是目前我发现的最合适的测试模组方法，没必要再重起炉灶，把它弄得好用点就是了。
常见的测试用例我已经添加进去了，请持续添加新的测试用例，不让一个bug溜走。
测试短信时，需针对实际手机号，自行构造pdu串。

未完成功能详见TODO
